"""
FastAPI Application for PDF Form Processing
Exposes endpoints to extract fields, fill forms, and visualize fields.
"""

from fastapi import FastAPI, File, UploadFile, HTTPException, BackgroundTasks, Form
from fastapi.responses import FileResponse, JSONResponse
from fastapi.middleware.cors import CORSMiddleware
import shutil
import os
from pathlib import Path
import uuid
import json
import zipfile

# Import our existing tools
from extract_pdf_fields import PDFFieldExtractor
from fill_pdf_form import PDFFormFiller
from highlight_fields_simple import highlight_fields_simple

app = FastAPI(
    title="PDF Form Processor API",
    description="API for extracting fields from PDF forms, filling them with dummy data, and visualizing fields.",
    version="1.1.0"
)

# Enable CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Create temp directory for uploads and processing
TEMP_DIR = Path("temp_api_files")
TEMP_DIR.mkdir(exist_ok=True)

def cleanup_file(path: Path):
    """Background task to remove temporary files."""
    try:
        if path.exists():
            if path.is_dir():
                shutil.rmtree(path)
            else:
                os.remove(path)
    except Exception as e:
        print(f"Error cleaning up file {path}: {e}")

@app.get("/")
async def root():
    return {"message": "Welcome to the PDF Form Processor API. Visit /docs for documentation."}

@app.post("/analyze-pdf/")
async def analyze_pdf(background_tasks: BackgroundTasks, file: UploadFile = File(...)):
    """
    Analyze a PDF: Extract fields to JSON and generate visualization images.
    Returns a ZIP file containing both.
    """
    if not file.filename.endswith('.pdf'):
        raise HTTPException(status_code=400, detail="File must be a PDF")

    file_id = str(uuid.uuid4())
    base_name = Path(file.filename).stem
    
    # Paths
    pdf_path = TEMP_DIR / f"{file_id}_{file.filename}"
    json_path = TEMP_DIR / f"{base_name}_fields.json"
    img_path = TEMP_DIR / f"{base_name}_highlighted.png"
    zip_path = TEMP_DIR / f"{base_name}_analysis.zip"
    
    try:
        # Save uploaded file
        with open(pdf_path, "wb") as buffer:
            shutil.copyfileobj(file.file, buffer)
        
        # 1. Extract fields
        extractor = PDFFieldExtractor(str(pdf_path))
        extractor.extract_fields()
        extractor.save_to_json(str(json_path))
        
        # 2. Generate Visualization (Page 1)
        # highlight_fields_simple returns the path string
        highlight_fields_simple(str(pdf_path), page_number=1, output_path=str(img_path))
        
        # 3. Create ZIP
        with zipfile.ZipFile(zip_path, 'w') as zipf:
            zipf.write(json_path, arcname=json_path.name)
            if img_path.exists():
                zipf.write(img_path, arcname=img_path.name)
        
        # Schedule cleanup
        background_tasks.add_task(cleanup_file, pdf_path)
        background_tasks.add_task(cleanup_file, json_path)
        background_tasks.add_task(cleanup_file, img_path)
        background_tasks.add_task(cleanup_file, zip_path)
        
        return FileResponse(
            path=zip_path,
            filename=f"{base_name}_analysis.zip",
            media_type='application/zip'
        )
        
    except Exception as e:
        # Clean up on error
        cleanup_file(pdf_path)
        cleanup_file(json_path)
        cleanup_file(img_path)
        cleanup_file(zip_path)
        raise HTTPException(status_code=500, detail=f"Error analyzing PDF: {str(e)}")

@app.post("/fill-pdf/")
async def fill_pdf(
    background_tasks: BackgroundTasks, 
    pdf_file: UploadFile = File(...), 
    json_file: UploadFile = File(...)
):
    """
    Fill a PDF form using data provided in a JSON file.
    The JSON should match the structure generated by /analyze-pdf/.
    """
    if not pdf_file.filename.endswith('.pdf'):
        raise HTTPException(status_code=400, detail="pdf_file must be a PDF")
    if not json_file.filename.endswith('.json'):
        raise HTTPException(status_code=400, detail="json_file must be a JSON")

    file_id = str(uuid.uuid4())
    
    # Paths
    pdf_path = TEMP_DIR / f"{file_id}_{pdf_file.filename}"
    output_pdf_path = TEMP_DIR / f"{file_id}_filled.pdf"
    
    try:
        # Save PDF
        with open(pdf_path, "wb") as buffer:
            shutil.copyfileobj(pdf_file.file, buffer)
            
        # Read JSON content directly
        json_content = await json_file.read()
        field_data = json.loads(json_content)
        
        # Fill Form
        # Pass the dict directly to PDFFormFiller
        filler = PDFFormFiller(str(pdf_path), field_data)
        
        # Use provided values from the JSON
        filler.fill_form(str(output_pdf_path), use_provided_values=True)
        
        # Schedule cleanup
        background_tasks.add_task(cleanup_file, pdf_path)
        background_tasks.add_task(cleanup_file, output_pdf_path)
        
        return FileResponse(
            path=output_pdf_path,
            filename=f"Filled_{pdf_file.filename}",
            media_type='application/pdf'
        )
        
    except Exception as e:
        cleanup_file(pdf_path)
        cleanup_file(output_pdf_path)
        raise HTTPException(status_code=500, detail=f"Error filling PDF: {str(e)}")

if __name__ == "__main__":
    import uvicorn
    print("Starting PDF Form API...")
    uvicorn.run(app, host="0.0.0.0", port=8000)
